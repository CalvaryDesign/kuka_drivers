### Requirements:

- KUKA LBR iiwa

- KUKA Sunrise Cabinet

  - Running Sunrise OS 1.16 (other versions might also work)

  - Sunrise FRI 1.16

- KUKA smartPAD

- Client computer

  - Connected with an ethernet cable to the KUKA Line Interface (KLI) of the Sunrise Cabinet

  - ROS2 foxy on real-time linux (preempt_rt)

  - kuka_sunrise metapackage is downloaded and built with **real** fri_client library linked

  - key_teleop package is downloaded (necessary for example application)

### System start-up

1. **Sync the Sunrise Project ROS2_Control to the robot**

   Start the Robot Application ROS2_Control.java, which contains a state machine and a TCP interface so that full control over the state of the robot can be realized from ROS2.

   After everything has started properly, controlling the robot is possible using the standard ROS2 tools. No interaction with the SmartPad is needed, except for when the application has to be stopped. However, the external control is terminated if a safety condition is triggered by the SmartPad.

2. **Set IP address of client machine in the Sunrise Project**

   Set the variable `_remoteIP` in the file serialization/FRIConfigurationParams of the Sunrise Project to the IP address of your client machine. (TODO: use rosparam)

3. **Set IP address of Sunrise Cabinet in the ROS2 sunrise driver**

   Set the parameter `controller_ip` in the launch file `launch/kuka_sunrise.launch.py`

Then continue with one of the following options:

#### Starting the robot driver only

4. **On the client machine run `ros2 launch kuka_sunrise kuka_sunrise.launch.py`**

   This launch file starts 2 nodes:

   - Robot Manager:

     Manages lifecycle, initiates connection to the Robot Application running on the Sunrise Cabinet, initiates real-time control, handles errors etc.

   - Robot Controller:

     Real-time monitoring and commanding of robot states through FRI

5. **Activate robot state monitoring with ROS2 lifecycle CLI**

   1. **`ros2 lifecycle set robot_manager configure`**

   Now the connection to the Robot Application should be established and the messages

   ```
   Command received: Connect
   Command executed.
   ```

   should appear on the smartPAD log.

   2. **`ros2 lifecycle set robot_manager activate`**

   Now the connection through the FRI should be established and the messages

   ```
   Command received: Start FRI
   Command executed.
   ```

   should appear on the smartPAD log. If the second message is missing, there was an error and the FRI session could not be started. In this case the command `ros2 lifecycle set robot_manager activate` also returns with a failure message on the client machine. The most likely issue is that the ports for the FRI were configured incorrectly, or they are not allowed through the firewall of the client machine. Refer to the Sunrise FRI documentation for more info on how to set up FRI.

6. **Monitor the robot state by running `ros2 topic echo /lbr_joint_state`**
  As of now this functionality is not working, as monitoring mode is not activated with the activation of the driver. Work on the solution of this bug is in proggress.

#### Starting the example application teleop_guided_robot

4. **On the client machine run `ros2 launch teleop_guided_robot teleop_guided_robot.launch.py`**

   This launch file starts the driver, a node for interpreting keyboard inputs, an interpolator (to avoid stopping the robot by velocities over the limits) and a system manager.

5. **Activate robot state control with the ROS2 lifecycle CLI**

   1. **`ros2 lifecycle set system_manager configure`**

   2. **`ros2 lifecycle set system_manager activate`**

6. **In a new terminal run `ros2 run key_teleop key_teleop`**

   You should now be able to operate the robot joint position from this window. You can increment/decrement the position of the active joint with the horizontal arrows and change the active joint with the vertical arrows.
   **NOTE**: if the key_teleop node errors, you should download the package from github (https://github.com/ros-teleop/teleop_tools)


#### Starting the driver with an interpolator to be able to move the robot with custom control

4. **On the client machine run `ros2 launch teleop_guided_robot sunrise_control.launch.py`**

   This launch file starts the driver, an interpolator and a system manager.

5. **Activate robot state control with the ROS2 lifecycle CLI**

   1. **`ros2 lifecycle set system_manager configure`**

   2. **`ros2 lifecycle set system_manager activate`**

   This activates all system components so you can poll robot states (`ros2 topic echo /lbr_joint_state`) or send joint commands on the _/lbr_joint_command_ topic with the following command to test moving the robot:

   `ros2 topic pub /reference_joint_state sensor_msgs/msg/JointState "{position: [0, 0, 0, 0, 0, 0, 0]}" --once`

   **CAUTION!** The robot can move really fast, with half of maximum allowed velocity, you should give a goal position close to the actual and reduce the allowed speed with the joint controller's _velocity_factors_ parameter (this specifies overrides for every joint)

   If you write your own application, you should just publish the required joint states on the _/lbr_joint_command_ topic. You should note, that the timing of the control cycles are always managed by the robot controller and it requests commands with a certain frequency (configurable with the _send_period_ms_ parameter). The joint controller makes sure that commands are always available, but you should be aware of the fact, that **commands sent to the driver are not written to the robot immediately, but only when the robot requests a new command**.

   It is also possible to extend the interpolator with a more complex control algorithm. All necessary functionalities of such a controller are implemented in the _JointControllerBase_ interface class (_robot_control_ package). Deriving from this class and overriding the pure virtual _controlLoopCallback()_ method with your own control algorithm is the suggested way to adhere to the current structure.


### Common issues

##### Configuration hangs

If configuration of the robot manager (or system manager) hangs and does not return anything, you are probably having a connection issue. Check if the IP address and Ethernet configurations are correct and make sure that the TCP port 30000 is on your Sunrise Cabinet.

##### Could not start FRI

If activation of the robot fails with the error message "Could not start FRI" and the SmartPad log shows that the command errored, you are probably compiling with the mock fri_client library. FRI client library is needed for starting FRI and sending commands to it, you should make sure that you compile with the real library.

##### FRI state is reduced to 2

If FRI state transitions to 2 and control stops during motion, the connection quality is not good enough for real-time communication. FRI has strict QoS policies that stop control by high jitter or latency, if such problems occur often, you should try to increase cycle time (_send_period_ms_ parameter) or check if your system is really capable to fulfill real-time requirements.
